设计模式

什么是设计模式：每一个设计模式描述了一个在我们周围不断重复发生的问题，已经解决该问题的解决方案的核心。

模式名称：设计词汇，该模式问题全部的概括
问题 ：问题必须满足一系列先决条件
解决方案：设计的组成部分，运用类和对象组合解决问题
效果：对于系统的灵活性，扩充性，可移植性。

MVC 视图模型
model是应用对象，view是屏幕上的显示，控制器是用户界面对用户交互的响应。视图保证正确显示了模型的状态，一旦模型数据辩护，模型将通知视图，视图刷新自己。
MVC的主要关系还是observer ， composite ，strategy 三个模式给出

1. Abstract Factory 提供一个创建一系列相关或者相互依赖对象的接口。

2. Adapter 将一个类的接口转换成另外一个接口，将原来接口不兼容而不能工作的类可以一起工作。

3. Bridge 将抽象部分与它的实现部分分离，使他们都可以独立的变化。

4. Builder 将复杂对象的构建和表示分离，同样的构建过程可以创建不同的表示。

5. chain of Responsibillity 为解除请求的发送者和接受者之间的耦合，是多个对象都有机会处理这个请求，将这些对象连成一链，并沿链传递请求，直到有对象能处理它。

6. Command  将一个请求封装为一个对象，用不同的请求对客户进行参数化，对请求排队，记录请求日志，支持可取消操作。

7. Composite [kəmˈpɑːzət]  复合模式 将对象组合成树形结构以表示 “部分-整体”的层次结构，使单个对象和复合对象的使用具有一致性。

8. Decorator [ˈdekəreɪtər] 裱糊匠/装饰模式 动态的给一个对象添加一些额外的职责，扩展功能而言，比子类更灵活。

9. Facade [fəˈsɑːd]  外观：为子系统的一组接口提供一个一致的界面，定义了一个高层的接口，使子系统更加容易使用。

10. Factory Method 定义一个用户创建对象的接口，让子类决定实例化，将一个类的实例化延迟到子类

11. Flyweight 共享，支持大量细粒度的对象。

12. InterPreter 解释器/翻译模式  给定一个语言，定义它的文法的一种表示，定义一个解释器，用来解释语言中的句子。

13. Iterator 迭代器 

14. Mediator 用一个中介对象来封装一系列的对象交互，中介使各个对象不需要显式的相关引用，从而使耦合松散，从而独立改变它们之间的交互。

15. Memento 备忘录模式 记忆碎片模式 在不破坏封装的前提下，捕获对象的内部状态，并在其它地方保存，这样以后就可以将该对象恢复到保存的状态。

16. observer 定义对象间一对多的依赖关系，当一个对象改变，所有以来他的对象都得到通知并刷新。

17. Prototype [ˈproʊtətaɪp] 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象

18. Proxy 为其它对象提供一个代理来控制对这个对象的访问

19. Singleton 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

20. State  允许一个对象在内部在其内部状态改变时改变它的行为，对象看起来似乎修改了它所属的类。

21. Strategy [ˈstrætədʒi] 策略模式 定义一系列的算法，把它们一个个的封装起来，使它们能相互替换，使得算法的变化可以独立于使用它的客户。

22. Template Method 模版方法 定义一个操作中的算法的骨架，将一些步骤延迟到子类中。可以使子类不改变一个算法的结构而重新定义该算法的某些特定步骤。

23. Visitor 访客模式：表示一个作用于某对象结构中的各元素的操作，是在不改变各元素类的前提下定义作用于这些元素的新操作。

    

|      | 创建型                                                      | 结构型                                                       | 行为型                                                       |
| ---- | ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 类   | Factory Method                                              | Adapter                                                      | Interpreter<br />Temlate Method                              |
| 对象 | Abstract Factory<br />Builder<br />Prototype<br />Singleton | Adapter<br />Bridge<br />Composite<br />Decorator<br />Facade<br />Flyweight<br />Proxy | Chain responsibility<br />Conmmand<br />Iterrtor<br />Mediator<br />Memento<br />Observer<br />State<br />Strategy<br />Visitor |



设计模式4步曲

1 寻找何时的对象

​	分析 抽象 封装

2 决定对象的粒度

​	对象的分解，组合，大量的小粒度对象，生成其他的对象，其它的对象访问

3 指定对象接口

​	对象的所有signature的集合就是interface

4 描述对象的实现

​	类 实例 类继承 子类 超类 抽象类 具体类
5 hello